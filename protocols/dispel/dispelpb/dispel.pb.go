// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protocols/dispel/dispelpb/dispel.proto

package dispelpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_ibalajiarun_go_consensus_peer_peerpb "github.com/ibalajiarun/go-consensus/peer/peerpb"
	commandpb "github.com/ibalajiarun/go-consensus/pkg/command/commandpb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RBState_Status int32

const (
	RBState_None     RBState_Status = 0
	RBState_Received RBState_Status = 1
	RBState_Echoed   RBState_Status = 2
	RBState_Readied  RBState_Status = 3
	RBState_Executed RBState_Status = 4
)

var RBState_Status_name = map[int32]string{
	0: "None",
	1: "Received",
	2: "Echoed",
	3: "Readied",
	4: "Executed",
}

var RBState_Status_value = map[string]int32{
	"None":     0,
	"Received": 1,
	"Echoed":   2,
	"Readied":  3,
	"Executed": 4,
}

func (x RBState_Status) String() string {
	return proto.EnumName(RBState_Status_name, int32(x))
}

func (RBState_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6dfd21e05e0c2ee, []int{1, 0}
}

type RBMessage_Type int32

const (
	RBMessage_Send  RBMessage_Type = 0
	RBMessage_Echo  RBMessage_Type = 1
	RBMessage_Ready RBMessage_Type = 2
)

var RBMessage_Type_name = map[int32]string{
	0: "Send",
	1: "Echo",
	2: "Ready",
}

var RBMessage_Type_value = map[string]int32{
	"Send":  0,
	"Echo":  1,
	"Ready": 2,
}

func (x RBMessage_Type) String() string {
	return proto.EnumName(RBMessage_Type_name, int32(x))
}

func (RBMessage_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6dfd21e05e0c2ee, []int{2, 0}
}

type ConsensusMessage_Type int32

const (
	ConsensusMessage_Estimate   ConsensusMessage_Type = 0
	ConsensusMessage_CoordValue ConsensusMessage_Type = 1
	ConsensusMessage_Aux        ConsensusMessage_Type = 2
)

var ConsensusMessage_Type_name = map[int32]string{
	0: "Estimate",
	1: "CoordValue",
	2: "Aux",
}

var ConsensusMessage_Type_value = map[string]int32{
	"Estimate":   0,
	"CoordValue": 1,
	"Aux":        2,
}

func (x ConsensusMessage_Type) String() string {
	return proto.EnumName(ConsensusMessage_Type_name, int32(x))
}

func (ConsensusMessage_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6dfd21e05e0c2ee, []int{3, 0}
}

type DispelMessage struct {
	// Types that are valid to be assigned to Type:
	//	*DispelMessage_Broadcast
	//	*DispelMessage_Consensus
	Type isDispelMessage_Type `protobuf_oneof:"type"`
}

func (m *DispelMessage) Reset()         { *m = DispelMessage{} }
func (m *DispelMessage) String() string { return proto.CompactTextString(m) }
func (*DispelMessage) ProtoMessage()    {}
func (*DispelMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6dfd21e05e0c2ee, []int{0}
}
func (m *DispelMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DispelMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DispelMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DispelMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DispelMessage.Merge(m, src)
}
func (m *DispelMessage) XXX_Size() int {
	return m.Size()
}
func (m *DispelMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DispelMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DispelMessage proto.InternalMessageInfo

type isDispelMessage_Type interface {
	isDispelMessage_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DispelMessage_Broadcast struct {
	Broadcast *RBMessage `protobuf:"bytes,1,opt,name=broadcast,proto3,oneof" json:"broadcast,omitempty"`
}
type DispelMessage_Consensus struct {
	Consensus *ConsensusMessage `protobuf:"bytes,2,opt,name=consensus,proto3,oneof" json:"consensus,omitempty"`
}

func (*DispelMessage_Broadcast) isDispelMessage_Type() {}
func (*DispelMessage_Consensus) isDispelMessage_Type() {}

func (m *DispelMessage) GetType() isDispelMessage_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DispelMessage) GetBroadcast() *RBMessage {
	if x, ok := m.GetType().(*DispelMessage_Broadcast); ok {
		return x.Broadcast
	}
	return nil
}

func (m *DispelMessage) GetConsensus() *ConsensusMessage {
	if x, ok := m.GetType().(*DispelMessage_Consensus); ok {
		return x.Consensus
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DispelMessage) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DispelMessage_Broadcast)(nil),
		(*DispelMessage_Consensus)(nil),
	}
}

type RBState struct {
	PeerID      github_com_ibalajiarun_go_consensus_peer_peerpb.PeerID `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3,casttype=github.com/ibalajiarun/go-consensus/peer/peerpb.PeerID" json:"peer_id,omitempty"`
	Status      RBState_Status                                         `protobuf:"varint,1,opt,name=status,proto3,enum=mirbftpb.RBState_Status" json:"status,omitempty"`
	Command     *commandpb.Command                                     `protobuf:"bytes,4,opt,name=command,proto3" json:"command,omitempty"`
	CommandHash []byte                                                 `protobuf:"bytes,5,opt,name=command_hash,json=commandHash,proto3" json:"command_hash,omitempty"`
}

func (m *RBState) Reset()         { *m = RBState{} }
func (m *RBState) String() string { return proto.CompactTextString(m) }
func (*RBState) ProtoMessage()    {}
func (*RBState) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6dfd21e05e0c2ee, []int{1}
}
func (m *RBState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RBState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RBState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RBState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RBState.Merge(m, src)
}
func (m *RBState) XXX_Size() int {
	return m.Size()
}
func (m *RBState) XXX_DiscardUnknown() {
	xxx_messageInfo_RBState.DiscardUnknown(m)
}

var xxx_messageInfo_RBState proto.InternalMessageInfo

func (m *RBState) GetPeerID() github_com_ibalajiarun_go_consensus_peer_peerpb.PeerID {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *RBState) GetStatus() RBState_Status {
	if m != nil {
		return m.Status
	}
	return RBState_None
}

func (m *RBState) GetCommand() *commandpb.Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *RBState) GetCommandHash() []byte {
	if m != nil {
		return m.CommandHash
	}
	return nil
}

type RBMessage struct {
	EpochNum    Epoch                                                  `protobuf:"varint,1,opt,name=epoch_num,json=epochNum,proto3,casttype=Epoch" json:"epoch_num,omitempty"`
	PeerID      github_com_ibalajiarun_go_consensus_peer_peerpb.PeerID `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3,casttype=github.com/ibalajiarun/go-consensus/peer/peerpb.PeerID" json:"peer_id,omitempty"`
	Type        RBMessage_Type                                         `protobuf:"varint,3,opt,name=type,proto3,enum=mirbftpb.RBMessage_Type" json:"type,omitempty"`
	Command     *commandpb.Command                                     `protobuf:"bytes,4,opt,name=command,proto3" json:"command,omitempty"`
	CommandHash []byte                                                 `protobuf:"bytes,5,opt,name=command_hash,json=commandHash,proto3" json:"command_hash,omitempty"`
}

func (m *RBMessage) Reset()         { *m = RBMessage{} }
func (m *RBMessage) String() string { return proto.CompactTextString(m) }
func (*RBMessage) ProtoMessage()    {}
func (*RBMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6dfd21e05e0c2ee, []int{2}
}
func (m *RBMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RBMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RBMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RBMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RBMessage.Merge(m, src)
}
func (m *RBMessage) XXX_Size() int {
	return m.Size()
}
func (m *RBMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_RBMessage.DiscardUnknown(m)
}

var xxx_messageInfo_RBMessage proto.InternalMessageInfo

func (m *RBMessage) GetEpochNum() Epoch {
	if m != nil {
		return m.EpochNum
	}
	return 0
}

func (m *RBMessage) GetPeerID() github_com_ibalajiarun_go_consensus_peer_peerpb.PeerID {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *RBMessage) GetType() RBMessage_Type {
	if m != nil {
		return m.Type
	}
	return RBMessage_Send
}

func (m *RBMessage) GetCommand() *commandpb.Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *RBMessage) GetCommandHash() []byte {
	if m != nil {
		return m.CommandHash
	}
	return nil
}

type ConsensusMessage struct {
	EpochNum Epoch                                                  `protobuf:"varint,1,opt,name=epoch_num,json=epochNum,proto3,casttype=Epoch" json:"epoch_num,omitempty"`
	PeerID   github_com_ibalajiarun_go_consensus_peer_peerpb.PeerID `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3,casttype=github.com/ibalajiarun/go-consensus/peer/peerpb.PeerID" json:"peer_id,omitempty"`
	RoundNum Round                                                  `protobuf:"varint,3,opt,name=round_num,json=roundNum,proto3,casttype=Round" json:"round_num,omitempty"`
	Type     ConsensusMessage_Type                                  `protobuf:"varint,4,opt,name=type,proto3,enum=mirbftpb.ConsensusMessage_Type" json:"type,omitempty"`
	Estimate int32                                                  `protobuf:"varint,5,opt,name=estimate,proto3" json:"estimate,omitempty"`
	Aux      []int32                                                `protobuf:"varint,6,rep,packed,name=aux,proto3" json:"aux,omitempty"`
}

func (m *ConsensusMessage) Reset()         { *m = ConsensusMessage{} }
func (m *ConsensusMessage) String() string { return proto.CompactTextString(m) }
func (*ConsensusMessage) ProtoMessage()    {}
func (*ConsensusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6dfd21e05e0c2ee, []int{3}
}
func (m *ConsensusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusMessage.Merge(m, src)
}
func (m *ConsensusMessage) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusMessage proto.InternalMessageInfo

func (m *ConsensusMessage) GetEpochNum() Epoch {
	if m != nil {
		return m.EpochNum
	}
	return 0
}

func (m *ConsensusMessage) GetPeerID() github_com_ibalajiarun_go_consensus_peer_peerpb.PeerID {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *ConsensusMessage) GetRoundNum() Round {
	if m != nil {
		return m.RoundNum
	}
	return 0
}

func (m *ConsensusMessage) GetType() ConsensusMessage_Type {
	if m != nil {
		return m.Type
	}
	return ConsensusMessage_Estimate
}

func (m *ConsensusMessage) GetEstimate() int32 {
	if m != nil {
		return m.Estimate
	}
	return 0
}

func (m *ConsensusMessage) GetAux() []int32 {
	if m != nil {
		return m.Aux
	}
	return nil
}

func init() {
	proto.RegisterEnum("mirbftpb.RBState_Status", RBState_Status_name, RBState_Status_value)
	proto.RegisterEnum("mirbftpb.RBMessage_Type", RBMessage_Type_name, RBMessage_Type_value)
	proto.RegisterEnum("mirbftpb.ConsensusMessage_Type", ConsensusMessage_Type_name, ConsensusMessage_Type_value)
	proto.RegisterType((*DispelMessage)(nil), "mirbftpb.DispelMessage")
	proto.RegisterType((*RBState)(nil), "mirbftpb.RBState")
	proto.RegisterType((*RBMessage)(nil), "mirbftpb.RBMessage")
	proto.RegisterType((*ConsensusMessage)(nil), "mirbftpb.ConsensusMessage")
}

func init() {
	proto.RegisterFile("protocols/dispel/dispelpb/dispel.proto", fileDescriptor_b6dfd21e05e0c2ee)
}

var fileDescriptor_b6dfd21e05e0c2ee = []byte{
	// 610 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x94, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0x86, 0x6d, 0xc7, 0x71, 0xe2, 0x69, 0xa9, 0x56, 0x0b, 0x07, 0x2b, 0x87, 0xa4, 0x04, 0x51,
	0xf5, 0xd0, 0x3a, 0xa8, 0x95, 0x38, 0x20, 0x71, 0x20, 0x6d, 0x45, 0x7b, 0xa0, 0x42, 0x5b, 0x04,
	0x12, 0x12, 0xaa, 0xd6, 0xde, 0x21, 0x31, 0xc4, 0x5e, 0xcb, 0x6b, 0xa3, 0xf6, 0x0d, 0x38, 0xf2,
	0x30, 0x1c, 0x78, 0x04, 0x8e, 0x95, 0xb8, 0x70, 0xaa, 0x50, 0xfa, 0x16, 0x3d, 0xa1, 0xdd, 0x38,
	0x69, 0x05, 0xaa, 0xc4, 0x01, 0x24, 0x2e, 0xd9, 0xd9, 0x99, 0x7f, 0x66, 0x67, 0xbe, 0xdd, 0x18,
	0xd6, 0xf2, 0x42, 0x96, 0x32, 0x96, 0x13, 0x35, 0x10, 0x89, 0xca, 0x71, 0x52, 0x2f, 0x79, 0x54,
	0x1b, 0xa1, 0x11, 0xd0, 0x76, 0x9a, 0x14, 0xd1, 0xdb, 0x32, 0x8f, 0x3a, 0x77, 0x46, 0x72, 0x24,
	0x8d, 0x73, 0xa0, 0xad, 0x59, 0xbc, 0x73, 0x2f, 0x7f, 0x3f, 0x1a, 0xc4, 0x32, 0x4d, 0x79, 0x26,
	0xe6, 0x6b, 0x1e, 0xcd, 0xad, 0x99, 0xa8, 0xff, 0xd1, 0x86, 0x5b, 0xbb, 0xa6, 0xea, 0x33, 0x54,
	0x8a, 0x8f, 0x90, 0x6e, 0x83, 0x1f, 0x15, 0x92, 0x8b, 0x98, 0xab, 0x32, 0xb0, 0x57, 0xed, 0xf5,
	0xa5, 0xad, 0xdb, 0xe1, 0xfc, 0xa8, 0x90, 0x0d, 0x6b, 0xdd, 0xbe, 0xc5, 0xae, 0x74, 0xf4, 0x11,
	0xf8, 0xb1, 0xcc, 0x14, 0x66, 0xaa, 0x52, 0x81, 0x63, 0x92, 0x3a, 0x57, 0x49, 0x3b, 0xf3, 0xd0,
	0xb5, 0xdc, 0x85, 0x7c, 0xe8, 0x81, 0x5b, 0x9e, 0xe6, 0xd8, 0xff, 0xec, 0x40, 0x8b, 0x0d, 0x8f,
	0x4a, 0x5e, 0x22, 0x7d, 0x03, 0xad, 0x1c, 0xb1, 0x38, 0x4e, 0x84, 0xa9, 0xe6, 0x0e, 0x77, 0xa7,
	0xe7, 0x3d, 0xef, 0x39, 0x62, 0x71, 0xb0, 0x7b, 0x79, 0xde, 0x7b, 0x38, 0x4a, 0xca, 0x71, 0x15,
	0x85, 0xb1, 0x4c, 0x07, 0x49, 0xc4, 0x27, 0xfc, 0x5d, 0xc2, 0x8b, 0x2a, 0x1b, 0x8c, 0xe4, 0xe6,
	0xa2, 0xee, 0x40, 0x17, 0x30, 0x3f, 0x79, 0x14, 0xce, 0x32, 0x99, 0xa7, 0xb7, 0x07, 0x82, 0x3e,
	0x00, 0x4f, 0x95, 0xbc, 0xac, 0x94, 0x19, 0x70, 0x65, 0x2b, 0xb8, 0x3e, 0xa0, 0xe9, 0x20, 0x3c,
	0x32, 0x71, 0x56, 0xeb, 0xe8, 0x06, 0xb4, 0x6a, 0x70, 0x81, 0x6b, 0xc6, 0xa3, 0xe1, 0x02, 0x69,
	0xb8, 0x33, 0xb3, 0xd8, 0x5c, 0x42, 0xef, 0xc2, 0x72, 0x6d, 0x1e, 0x8f, 0xb9, 0x1a, 0x07, 0xcd,
	0x55, 0x7b, 0x7d, 0x99, 0x2d, 0xd5, 0xbe, 0x7d, 0xae, 0xc6, 0xfd, 0xa7, 0xe0, 0xcd, 0x8e, 0xa0,
	0x6d, 0x70, 0x0f, 0x65, 0x86, 0xc4, 0xa2, 0xcb, 0xd0, 0x66, 0x18, 0x63, 0xf2, 0x01, 0x05, 0xb1,
	0x29, 0x80, 0xb7, 0x17, 0x8f, 0x25, 0x0a, 0xe2, 0xd0, 0x25, 0x68, 0x31, 0xe4, 0x22, 0x41, 0x41,
	0x1a, 0x5a, 0xb6, 0x77, 0x82, 0x71, 0x55, 0xa2, 0x20, 0x6e, 0xff, 0x8b, 0x03, 0xfe, 0xe2, 0x56,
	0xe8, 0x1a, 0xf8, 0x98, 0xcb, 0x78, 0x7c, 0x9c, 0x55, 0xa9, 0x19, 0xce, 0x1d, 0xfa, 0x97, 0xe7,
	0xbd, 0xe6, 0x9e, 0x76, 0xb2, 0xb6, 0x89, 0x1d, 0x56, 0xe9, 0xbf, 0x06, 0xbc, 0x31, 0xbb, 0xd3,
	0xa0, 0xf1, 0x3b, 0xde, 0xba, 0xd3, 0xf0, 0xc5, 0x69, 0x8e, 0xcc, 0xa8, 0xfe, 0x3e, 0xdc, 0xfb,
	0xe0, 0xea, 0xf2, 0x1a, 0xed, 0x11, 0x66, 0x82, 0x58, 0xda, 0xd2, 0x30, 0x89, 0x4d, 0x7d, 0x68,
	0x6a, 0x94, 0xa7, 0xc4, 0xe9, 0x7f, 0x73, 0x80, 0xfc, 0xfa, 0x36, 0xff, 0x17, 0x82, 0x6b, 0xe0,
	0x17, 0xb2, 0xca, 0x84, 0x69, 0xa3, 0x71, 0xd5, 0x06, 0xd3, 0x4e, 0xd6, 0x36, 0x31, 0xdd, 0xc6,
	0x76, 0x4d, 0xda, 0x35, 0xa4, 0x7b, 0x37, 0xff, 0xe9, 0xae, 0x03, 0xef, 0x40, 0x1b, 0x55, 0x99,
	0xa4, 0xbc, 0x44, 0x83, 0xaf, 0xc9, 0x16, 0x7b, 0x4a, 0xa0, 0xc1, 0xab, 0x93, 0xc0, 0x5b, 0x6d,
	0xac, 0x37, 0x99, 0x36, 0xfb, 0x9b, 0x35, 0x4d, 0xfd, 0xee, 0x6a, 0x15, 0xb1, 0xe8, 0x0a, 0xc0,
	0x8e, 0x94, 0x85, 0x78, 0xc9, 0x27, 0x15, 0x12, 0x9b, 0xb6, 0xa0, 0xf1, 0xa4, 0x3a, 0x21, 0xce,
	0xf0, 0xd5, 0xd7, 0x69, 0xd7, 0x3e, 0x9b, 0x76, 0xed, 0x1f, 0xd3, 0xae, 0xfd, 0xe9, 0xa2, 0x6b,
	0x9d, 0x5d, 0x74, 0xad, 0xef, 0x17, 0x5d, 0xeb, 0xf5, 0xe3, 0x3f, 0x62, 0x72, 0xd3, 0xd7, 0x2f,
	0xf2, 0x4c, 0x68, 0xfb, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x47, 0xe9, 0x71, 0xbd, 0x21, 0x05,
	0x00, 0x00,
}

func (m *DispelMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DispelMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispelMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DispelMessage_Broadcast) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispelMessage_Broadcast) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Broadcast != nil {
		{
			size, err := m.Broadcast.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDispel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DispelMessage_Consensus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispelMessage_Consensus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Consensus != nil {
		{
			size, err := m.Consensus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDispel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RBState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RBState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RBState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CommandHash) > 0 {
		i -= len(m.CommandHash)
		copy(dAtA[i:], m.CommandHash)
		i = encodeVarintDispel(dAtA, i, uint64(len(m.CommandHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Command != nil {
		{
			size, err := m.Command.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDispel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PeerID != 0 {
		i = encodeVarintDispel(dAtA, i, uint64(m.PeerID))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintDispel(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RBMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RBMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RBMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CommandHash) > 0 {
		i -= len(m.CommandHash)
		copy(dAtA[i:], m.CommandHash)
		i = encodeVarintDispel(dAtA, i, uint64(len(m.CommandHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Command != nil {
		{
			size, err := m.Command.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDispel(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintDispel(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerID != 0 {
		i = encodeVarintDispel(dAtA, i, uint64(m.PeerID))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochNum != 0 {
		i = encodeVarintDispel(dAtA, i, uint64(m.EpochNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aux) > 0 {
		dAtA6 := make([]byte, len(m.Aux)*10)
		var j5 int
		for _, num1 := range m.Aux {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintDispel(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x32
	}
	if m.Estimate != 0 {
		i = encodeVarintDispel(dAtA, i, uint64(m.Estimate))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintDispel(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.RoundNum != 0 {
		i = encodeVarintDispel(dAtA, i, uint64(m.RoundNum))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerID != 0 {
		i = encodeVarintDispel(dAtA, i, uint64(m.PeerID))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochNum != 0 {
		i = encodeVarintDispel(dAtA, i, uint64(m.EpochNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDispel(dAtA []byte, offset int, v uint64) int {
	offset -= sovDispel(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DispelMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *DispelMessage_Broadcast) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Broadcast != nil {
		l = m.Broadcast.Size()
		n += 1 + l + sovDispel(uint64(l))
	}
	return n
}
func (m *DispelMessage_Consensus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Consensus != nil {
		l = m.Consensus.Size()
		n += 1 + l + sovDispel(uint64(l))
	}
	return n
}
func (m *RBState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovDispel(uint64(m.Status))
	}
	if m.PeerID != 0 {
		n += 1 + sovDispel(uint64(m.PeerID))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovDispel(uint64(l))
	}
	l = len(m.CommandHash)
	if l > 0 {
		n += 1 + l + sovDispel(uint64(l))
	}
	return n
}

func (m *RBMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochNum != 0 {
		n += 1 + sovDispel(uint64(m.EpochNum))
	}
	if m.PeerID != 0 {
		n += 1 + sovDispel(uint64(m.PeerID))
	}
	if m.Type != 0 {
		n += 1 + sovDispel(uint64(m.Type))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovDispel(uint64(l))
	}
	l = len(m.CommandHash)
	if l > 0 {
		n += 1 + l + sovDispel(uint64(l))
	}
	return n
}

func (m *ConsensusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochNum != 0 {
		n += 1 + sovDispel(uint64(m.EpochNum))
	}
	if m.PeerID != 0 {
		n += 1 + sovDispel(uint64(m.PeerID))
	}
	if m.RoundNum != 0 {
		n += 1 + sovDispel(uint64(m.RoundNum))
	}
	if m.Type != 0 {
		n += 1 + sovDispel(uint64(m.Type))
	}
	if m.Estimate != 0 {
		n += 1 + sovDispel(uint64(m.Estimate))
	}
	if len(m.Aux) > 0 {
		l = 0
		for _, e := range m.Aux {
			l += sovDispel(uint64(e))
		}
		n += 1 + sovDispel(uint64(l)) + l
	}
	return n
}

func sovDispel(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDispel(x uint64) (n int) {
	return sovDispel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DispelMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDispel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DispelMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DispelMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Broadcast", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDispel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDispel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RBMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &DispelMessage_Broadcast{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consensus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDispel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDispel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsensusMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &DispelMessage_Consensus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDispel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDispel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDispel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RBState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDispel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RBState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RBState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RBState_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= github_com_ibalajiarun_go_consensus_peer_peerpb.PeerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDispel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDispel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &commandpb.Command{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDispel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDispel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandHash = append(m.CommandHash[:0], dAtA[iNdEx:postIndex]...)
			if m.CommandHash == nil {
				m.CommandHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDispel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDispel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDispel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RBMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDispel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RBMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RBMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNum", wireType)
			}
			m.EpochNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNum |= Epoch(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= github_com_ibalajiarun_go_consensus_peer_peerpb.PeerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= RBMessage_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDispel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDispel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &commandpb.Command{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDispel
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDispel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandHash = append(m.CommandHash[:0], dAtA[iNdEx:postIndex]...)
			if m.CommandHash == nil {
				m.CommandHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDispel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDispel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDispel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDispel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNum", wireType)
			}
			m.EpochNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNum |= Epoch(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= github_com_ibalajiarun_go_consensus_peer_peerpb.PeerID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundNum", wireType)
			}
			m.RoundNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundNum |= Round(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ConsensusMessage_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Estimate", wireType)
			}
			m.Estimate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Estimate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDispel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Aux = append(m.Aux, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDispel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDispel
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDispel
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Aux) == 0 {
					m.Aux = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDispel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Aux = append(m.Aux, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Aux", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDispel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDispel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDispel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDispel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDispel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDispel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDispel
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDispel
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDispel
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDispel        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDispel          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDispel = fmt.Errorf("proto: unexpected end of group")
)
